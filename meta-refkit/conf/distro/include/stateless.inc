INHERIT += "stateless"

# Gets re-created by systemd already.
STATELESS_RM += "mtab"

# Both systemd and connman create this via tmpfiles.d. connman happens
# to win because it connman.conf sorts before etc.conf, but that's
# a bit brittle, so we ensure that connman wins if installed.
STATELESS_RM += " \
    resolv.conf \
"
STATELESS_POSTPROCESS_COMMAND += "stateless_connman_resolv_conf;"
stateless_connman_resolv_conf () {
    if [ -f "${IMAGE_ROOTFS}/${libdir}/tmpfiles.d/connman.conf" ] &&
       [ -f "${IMAGE_ROOTFS}/${libdir}/tmpfiles.d/etc.conf" ]; then
        sed -i -e 's;^\(L! /etc/resolv.conf \);# stateless: replaced by connman: \1;' \
            "${IMAGE_ROOTFS}/${libdir}/tmpfiles.d/etc.conf"
    fi
}

# machine-id can be removed if the rootfs and thus /etc get mounted read/write,
# because then systemd is able to create it during early startup.
# Beware that removing machine-id triggers systemd's FirstBootCondition,
# which may or may not be intended because normally OE-based images
# always boot without it.
#
# systemd also enables units during such a first boot according to their [Install]
# section, which at least for wpa-supplicant turned out to be broken.
#
# The default is to remove machine-id when possible. This can be overriden
# with STATELESS_ETC_WHITELIST_append = "machine-id"
STATELESS_ETC_WHITELIST += " \
    ${@ 'machine-id' if 'ro' in (d.getVar('APPEND') or '').split() else '' } \
"
STATELESS_POSTPROCESS_COMMAND += "stateless_rm_machineid; "
stateless_rm_machineid () {
    if ${@ bb.utils.contains('STATELESS_ETC_WHITELIST', 'machine-id', 'false', 'true', d) }; then
        rm -f "${IMAGE_ROOTFS}${sysconfdir}/machine-id"
    fi
}

# wpa-supplicant has a broken [Install] section: it uses a wildcard
# that gets expanded to wpa_supplicant@multi-user.service and thus
# a dependency on a "multi-user" device, causing delays during
# booting. See http://lists.infradead.org/pipermail/hostap/2017-March/037330.html
# TODO: We fix that up here because it triggers when we enable the FirstBootCondition,
# but ultimately this should go upstream and into wpa-supplicant packaging.
STATELESS_POSTPROCESS_COMMAND += "stateless_wpa_supplicant; "
stateless_wpa_supplicant () {
    for i in ${IMAGE_ROOTFS}${systemd_system_unitdir}/wpa_supplicant*@.service; do
        if [ -e "$i" ]; then
            sed -i -e 's;^\(Alias=multi-user.target.wants/wpa_supplicant.*@%i.service\);# stateless: broken wildcard usage: \1;' "$i"
        fi
    done
}

# /etc/ssl/certs gets generated by update-ca-certificates. tmpfiles.d
# has no built mechanism for generating content via commands, so we emulate
# that here by piggy-backing the command onto systemd-tmpfiles-setup.service.
STATELESS_POSTPROCESS_COMMAND += "stateless_ca_certificates; "
stateless_ca_certificates () {
    if [ -x "${IMAGE_ROOTFS}${sbindir}/update-ca-certificates" ] &&
       [ -d "${IMAGE_ROOTFS}${sysconfdir}/ssl/certs" ]; then
        bbnote "stateless: removing ${sysconfdir}/ssl/certs and recreating it at boot time with update-ca-certificates"
        rm -r "${IMAGE_ROOTFS}${sysconfdir}/ssl/certs"
        install -d "${IMAGE_ROOTFS}${systemd_system_unitdir}/systemd-tmpfiles-setup.service.d"
        cat >"${IMAGE_ROOTFS}${systemd_system_unitdir}/systemd-tmpfiles-setup.service.d/stateless-update-ca-certificates.conf" <<EOF
[Service]
ExecStartPost=/bin/sh -c '[ -d ${sysconfdir}/ssl/certs ] || (mkdir -p ${sysconfdir}/ssl/certs && ${sbindir}/update-ca-certificates)'
EOF
    fi
}
REFKIT_QA_IMAGE_SYMLINK_WHITELIST_append = " ${sysconfdir}/ssl/certs"

# Depend on the installed components and thus has to be computed on
# the device. Handled by systemd during booting or updates.
STATELESS_RM_ROOTFS += " \
    udev/hwdb.bin \
"

# Disable creation of /etc/ld.so.cache in images and bundles. The file
# gets already recreated by systemd anyway when booting. Has to be
# done by unsetting LDCONFIGDEPEND (checked by rootfs.py, which
# creates the ld.so.cache).
python () {
    if oe.types.boolean(d.getVar('STATELESS_ACTIVE')):
        d.setVar('LDCONFIGDEPEND', '')
}
